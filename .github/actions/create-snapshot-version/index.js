const core = require('@actions/core');
const github = require('@actions/github');
const {getExecOutput} = require('@actions/exec');
const {getPackages} = require('@manypkg/get-packages');


const main = async () => {
    // const token = core.getInput('GITHUB_TOKEN');
    const branchName = 'snapshot-release/emma/new-branch';

    const cwd = process.cwd();

    const {packages} = await getPackages(cwd);

    const snapshotReleases = ['emmas-monorepo@snapshot-0-0-0'];
    for (let index = 0; index < packages.length; index++) {
      const {packageJson, relativeDir} = packages[index];

      const pkgName = packageJson.name;
      const localVersion = packageJson.version;

      console.log('name and version', pkgName, localVersion);

      if (localVersion.includes('snapshot')){
        snapshotReleases.push(localVersion);
      }
      // 

    }

    core.setOutput('SNAPSHOT_RELEASES', snapshotReleases);
    // const branchName = 'test-version-flow';

    // const octokit = github.getOctokit(token);



    // const versionFiles = await getUncomittedPackageVersionFiles(/package.json/);

    // if (versionFiles.length > 0) {
  
    //     console.log('✅ Version files found. Creating Snapshot release');

    //     versionFiles.forEach((versionFile) => {
    //       console.log(versionFile.name);
    //       // Create commit including the version number

    //       // Extract the version number to share between steps. Or maybe don't. 
    //     })

    
    // }
    //     else {
    //         console.log(
    //             '⛔ No Version files found. Snapshot releases require at least one changset.',
    //           );

    //     }

    //     async function getUncomittedPackageVersionFiles() {
    //         // output returns a string, with each file name and status seperated by linebreaks.
    //         const output = await getExecOutput('git', ['status', '--porcelain']);
          
    //         // Tranform string into an array
    //         let files = output.stdout.split(/\r?\n/);
    //         // Remove empty entry after final linebreak
    //         files = files.splice(0, files.length - 1);
          
    //         // only return files that were generated by "changeset version"
    //         // todo: only from packages, not github actions
    //         const versionFileIdentifiers = /package.json/;
    //         const uncomittedVersionFiles = files.filter((file) =>
    //           versionFileIdentifiers.test(file),
    //         );
          
    //         return uncomittedVersionFiles.map((file) => {
    //           // Initial Status format: XY PATH
    //           const fileDetails = file.replace(/^\s+/, '').split(/[ ]/);
    //           // Status codes: https://git-scm.com/docs/git-status
    //           const status = fileDetails[0];
    //           const name = fileDetails.pop();
          
    //           return {
    //             name,
    //             status,
    //           };
    //         });
    //       }


}

main().catch((err) => core.setFailed(err.message));
