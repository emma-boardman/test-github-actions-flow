const core = require('@actions/core');
const github = require('@actions/github');
const {getExecOutput} = require('@actions/exec');
const {getPackages} = require('@manypkg/get-packages');


const main = async () => {
    const token = core.getInput('GITHUB_TOKEN');
    const branchName = 'snapshot-release/emma/new-branch';

    const octokit = github.getOctokit(token);

    const cwd = process.cwd();

    const {packages} = await getPackages(cwd);

    const snapshotReleases = ['emmas-monorepo@snapshot-0-0-0'];
    for (let index = 0; index < packages.length; index++) {
      const {packageJson, relativeDir} = packages[index];

      const pkgName = packageJson.name;
      const localVersion = packageJson.version;

      console.log('name and version', pkgName, localVersion);

      if (localVersion.includes('snapshot')){
        snapshotReleases.push(localVersion);


        
      }
      // 

    }

    core.setOutput('SNAPSHOT_RELEASES', snapshotReleases);
    // const branchName = 'test-version-flow';

    // const octokit = github.getOctokit(token);



    const versionFiles = await getUncomittedPackageVersionFiles(/package.json/);

    if (versionFiles.length > 0) {

         // Locally commit version file
        await getExecOutput('git', ['fetch']);
  
        console.log('✅ Version files found. Creating Snapshot release');

        versionFiles.forEach(async (versionFile) => {
          console.log(versionFile.name);
          // Add the file

          await getExecOutput('git', ['add', versionFile.name]);

          // Extract the version number to share between steps. Or maybe don't. 
        })
        await getExecOutput('git', ['commit', '-m', 'Snapshot Version']);
        const lastCommit = await getExecOutput('git', ['rev-parse', 'HEAD']);
      console.log('lastCommit', lastCommit);

       const {data} = octokit.rest.git.updateRef({
          ref: 'refs/heads/snapshot-release/emma/new-branch',
          sha: lastCommit,
          ...github.context.repo,
        });

        console.log('data',data);

    
    }
        else {
            console.log(
                '⛔ No Version files found. Snapshot releases require at least one changset.',
              );

        }





        async function getUncomittedPackageVersionFiles() {
            // output returns a string, with each file name and status seperated by linebreaks.
            const output = await getExecOutput('git', ['status', '--porcelain']);
          
            // Tranform string into an array
            let files = output.stdout.split(/\r?\n/);
            // Remove empty entry after final linebreak
            files = files.splice(0, files.length - 1);
          
            // only return files that were generated by "changeset version"
            // todo: only from packages, not github actions
            const versionFileIdentifiers = /package.json/;
            const uncomittedVersionFiles = files.filter((file) =>
              versionFileIdentifiers.test(file),
            );
          
            return uncomittedVersionFiles.map((file) => {
              // Initial Status format: XY PATH
              const fileDetails = file.replace(/^\s+/, '').split(/[ ]/);
              // Status codes: https://git-scm.com/docs/git-status
              const status = fileDetails[0];
              const name = fileDetails.pop();
          
              return {
                name,
                status,
              };
            });
          }


}

main().catch((err) => core.setFailed(err.message));
